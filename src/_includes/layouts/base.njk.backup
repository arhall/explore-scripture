<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <!-- Security Headers -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://www.biblegateway.com https://api.esv.org https://www.youtube.com https://www.gstatic.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: https: https://i.ytimg.com https://yt3.ggpht.com; connect-src 'self' https://api.esv.org https://bible-api.com https://www.biblegateway.com https://www.youtube.com; frame-src 'self' https://www.biblegateway.com https://www.youtube.com https://www.youtube-nocookie.com https://enduringword.com https://www.biblestudytools.com https://www.studylight.org https://biblehub.com; base-uri 'self'; form-action 'self'; upgrade-insecure-requests;">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="SAMEORIGIN">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=(), payment=(), usb=(), magnetometer=(), gyroscope=(), accelerometer=()">
  
  <link rel="icon" href="/assets/favicon.svg" type="image/svg+xml">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#2563eb">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="Bible Explorer">
  <title>{{ title or 'Bible Explorer' }}</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
  <meta name="description" content="{{ description or 'Chapter-by-chapter Bible summaries with categories and metadata.' }}">
  <!-- Performance Optimizers (loaded first) -->
  <script src="/assets/css-optimizer.js" async></script>
  <script src="/assets/image-optimizer.js" async></script>
  
  <!-- Module Loader (handles all other JS loading) -->
  <script src="/assets/module-loader.js"></script>
  
  <!-- OpenTelemetry Web SDK (loaded lazily via module loader) -->
  <link rel="preload" href="https://unpkg.com/@opentelemetry/api@1.7.0/build/esm/index.js" as="script" crossorigin>
  <link rel="preload" href="https://unpkg.com/@opentelemetry/sdk-web@1.19.0/build/esm/index.js" as="script" crossorigin>
  <link rel="preload" href="https://unpkg.com/@opentelemetry/auto-instrumentations-web@0.35.0/build/esm/index.js" as="script" crossorigin>
</head>
<body>
  <div class="container">
    <nav class="nav">
      <a class="nav-brand" href="/">Bible Explorer</a>
      <div class="nav-links">
        <a href="/categories/" class="nav-link {% if page.url == '/categories/' %}active{% endif %}">Sections</a>
        <a href="/characters/" class="nav-link {% if page.url.startsWith('/characters/') %}active{% endif %}">Characters</a>
        <a href="/gospel-thread/" class="nav-link {% if page.url == '/gospel-thread/' %}active{% endif %}">Gospel Thread</a>
        <a href="/links/" class="nav-link {% if page.url == '/links/' %}active{% endif %}">Links</a>
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
          <span class="theme-icon">ðŸŒ™</span>
        </button>
        <button class="font-size-toggle" onclick="toggleFontSizeControls()" aria-label="Toggle font size controls">
          <span class="font-size-icon">Aa</span>
        </button>
        <button class="high-contrast-toggle" onclick="toggleHighContrast()" aria-label="Toggle high contrast mode">
          <span class="high-contrast-icon">â—»</span>
        </button>
        <button class="recents-bookmarks-toggle" onclick="toggleRecentsBookmarks()" aria-label="Toggle recent items and bookmarks">
          <span class="recents-icon">â˜…</span>
        </button>
      </div>
    </nav>
    
    <div class="recents-bookmarks-panel" id="recentsBookmarksPanel">
      <div class="recents-bookmarks-content">
        <div class="recents-bookmarks-header">
          <h3>Quick Access</h3>
          <button class="close-panel-btn" onclick="toggleRecentsBookmarks()">Ã—</button>
        </div>
        
        <div class="recents-bookmarks-tabs">
          <button class="tab-btn active" onclick="switchTab('bookmarks')" id="bookmarksTab">
            <span class="tab-icon">â˜…</span>
            Bookmarks (<span id="bookmarksCount">0</span>)
          </button>
          <button class="tab-btn" onclick="switchTab('recent')" id="recentTab">
            <span class="tab-icon">â†»</span>
            Recent (<span id="recentCount">0</span>)
          </button>
        </div>
        
        <div class="tab-content active" id="bookmarksContent">
          <div class="tab-actions">
            <button class="clear-all-btn" onclick="clearAllBookmarks()">Clear All</button>
          </div>
          <div class="items-list" id="bookmarksList">
            <div class="empty-state">
              <div class="empty-icon">â˜…</div>
              <p>No bookmarks yet</p>
              <small>Bookmark pages to access them quickly later</small>
            </div>
          </div>
        </div>
        
        <div class="tab-content" id="recentContent">
          <div class="tab-actions">
            <button class="clear-all-btn" onclick="clearAllRecentItems()">Clear All</button>
          </div>
          <div class="items-list" id="recentsList">
            <div class="empty-state">
              <div class="empty-icon">â†»</div>
              <p>No recent items</p>
              <small>Pages you visit will appear here</small>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="font-size-panel" id="fontSizePanel">
      <div class="font-size-content">
        <div class="font-size-header">
          <h3>Text Size</h3>
          <button class="close-font-panel" onclick="toggleFontSizeControls()">Ã—</button>
        </div>
        
        <div class="font-size-controls">
          <div class="font-size-presets">
            <button class="font-preset-btn" data-size="small" onclick="setFontSize('small')">
              <span class="preset-label">Small</span>
              <span class="preset-sample">Aa</span>
            </button>
            <button class="font-preset-btn active" data-size="medium" onclick="setFontSize('medium')">
              <span class="preset-label">Medium</span>
              <span class="preset-sample">Aa</span>
            </button>
            <button class="font-preset-btn" data-size="large" onclick="setFontSize('large')">
              <span class="preset-label">Large</span>
              <span class="preset-sample">Aa</span>
            </button>
            <button class="font-preset-btn" data-size="extra-large" onclick="setFontSize('extra-large')">
              <span class="preset-label">Extra Large</span>
              <span class="preset-sample">Aa</span>
            </button>
          </div>
          
          <div class="font-size-slider-container">
            <label for="fontSizeSlider">Custom Size</label>
            <div class="slider-wrapper">
              <span class="slider-label">A</span>
              <input type="range" id="fontSizeSlider" min="80" max="140" value="100" step="5" oninput="setCustomFontSize(this.value)">
              <span class="slider-label large">A</span>
            </div>
            <div class="slider-value" id="sliderValue">100%</div>
          </div>
          
          <div class="font-options">
            <label class="font-option">
              <input type="checkbox" id="dyslexiaFont" onchange="toggleDyslexiaFont(this.checked)">
              <span class="checkmark-text">Dyslexia-friendly font</span>
            </label>
            <label class="font-option">
              <input type="checkbox" id="increaseLineHeight" onchange="toggleLineHeight(this.checked)">
              <span class="checkmark-text">Increase line spacing</span>
            </label>
          </div>
          
          <div class="font-actions">
            <button class="btn-secondary" onclick="resetFontSettings()">Reset to Default</button>
          </div>
        </div>
      </div>
    </div>
    
    
    {% include "components/breadcrumb.njk" %}
    
    {{ content | safe }}
    
    <footer class="footer">
      Built with <a href="https://www.11ty.dev/">Eleventy</a> â€¢ 2024
    </footer>
  </div>

  <script>
    // Search functionality
    let searchData = [];
    let searchTimeout;
    let searchHistory = [];
    let recentItems = [];
    let bookmarkedItems = [];

    // Initialize search data
    async function initializeSearch() {
      try {
        const books = {% if books %}{{ books | dump | safe }}{% else %}[]{% endif %};
        const categories = {% if categories %}{{ categories | dump | safe }}{% else %}[]{% endif %};
        const characters = {% if characters %}{{ characters | dump | safe }}{% else %}[]{% endif %};
        const gospelThreads = {% if gospelThreads %}{{ gospelThreads | dump | safe }}{% else %}{}{% endif %};
        const crossReferences = {% if crossReferences %}{{ crossReferences | dump | safe }}{% else %}{}{% endif %};
        
        // Only show error if we're on a page that should have data
        const shouldHaveData = window.location.pathname.includes('/books/') || 
                              window.location.pathname.includes('/characters/') || 
                              window.location.pathname.includes('/categories/');
        
        if (shouldHaveData && (!books || !Array.isArray(books) || books.length === 0)) {
          throw new Error('Books data is invalid or missing');
        }
        
        // Continue with empty arrays if no data available (like on homepage)
        if (!Array.isArray(books) || books.length === 0) {
          if (window.logger) {
            window.logger.info('No books data available for search - likely on homepage or non-content page');
          }
          // Initialize empty search data but don't throw error
          searchData = [];
          return;
        }
        
        // Process books and chapters into searchable items
        books.forEach((book, index) => {
          try {
            if (!book.name || !book.slug) {
              throw new Error(`Book at index ${index} missing required fields`);
            }
            
            // Add book itself
            let bookSubtitle = `Book by ${book.author || 'Unknown'} â€¢ ${book.category || 'Unknown'}`;
            
            // Special handling for single-chapter books that might be confused with characters
            const singleChapterBooks = ['Obadiah', 'Philemon', 'Jude', '2 John', '3 John'];
            if (singleChapterBooks.includes(book.name)) {
              bookSubtitle = `Single-chapter book by ${book.author || 'Unknown'} â€¢ ${book.category || 'Unknown'}`;
            }
            
            searchData.push({
              type: 'book',
              title: book.name,
              subtitle: bookSubtitle,
              content: `${book.name} ${book.author || ''} ${book.category || ''} ${book.testament || ''}`,
              url: `/books/${book.slug}/`,
              typeLabel: 'Book',
              testament: book.testament,
              category: book.category
            });

            // Add chapters with summaries
            if (book.chapterSummaries && typeof book.chapterSummaries === 'object') {
              Object.entries(book.chapterSummaries).forEach(([chapter, summary]) => {
                if (summary && typeof summary === 'string') {
                  searchData.push({
                    type: 'chapter',
                    title: `${book.name} ${chapter}`,
                    subtitle: `${summary.substring(0, 80)}...`,
                    content: `${book.name} chapter ${chapter} ${summary}`,
                    url: `/books/${book.slug}/#chapter-${chapter}`,
                    typeLabel: 'Chapter',
                    testament: book.testament,
                    category: book.category
                  });
                }
              });
            }
          } catch (bookError) {
            if (window.logger) {
              window.logger.error('Error processing book for search', { 
                book: book.name || 'unknown', 
                error: bookError.message 
              });
            }
          }
        });

        // Add categories
        if (Array.isArray(categories)) {
          categories.forEach((category, index) => {
          try {
            if (!category.name || !category.slug) {
              throw new Error(`Category at index ${index} missing required fields`);
            }
            
            searchData.push({
              type: 'category',
              title: category.name,
              subtitle: `${category.description || 'Biblical section'}`,
              content: `${category.name} ${category.description || ''} ${category.themes ? category.themes.join(' ') : ''}`,
              url: `/categories/${category.slug}/`,
              typeLabel: 'Section'
            });
          } catch (categoryError) {
            if (window.logger) {
              window.logger.error('Error processing category for search', { 
                category: category.name || 'unknown', 
                error: categoryError.message 
              });
            }
          }
        });
        }

        // Add characters
        if (Array.isArray(characters)) {
          characters.forEach((character, index) => {
          try {
            if (!character.name || !character.slug) {
              throw new Error(`Character at index ${index} missing required fields`);
            }
            
            searchData.push({
              type: 'character',
              title: character.name,
              subtitle: `${character.totalAppearances} appearances in ${character.totalBooks} books`,
              content: `${character.name} ${character.books ? character.books.join(' ') : ''}`,
              url: `/characters/${character.slug}/`,
              typeLabel: 'Character'
            });
          } catch (characterError) {
            if (window.logger) {
              window.logger.error('Error processing character for search', { 
                character: character.name || 'unknown', 
                error: characterError.message 
              });
            }
          }
        });
        }

        // Add Gospel Thread themes
        if (gospelThreads && gospelThreads.coreThemes) {
          Object.entries(gospelThreads.coreThemes).forEach(([themeId, theme]) => {
            searchData.push({
              type: 'gospel-theme',
              title: theme.name,
              subtitle: `${theme.description}`,
              content: `${theme.name} ${theme.description} ${theme.gospelConnection} gospel christ jesus salvation`,
              url: `/gospel-thread/#theme-${themeId}`,
              typeLabel: 'Gospel Theme'
            });
          });
        }
        
        // Load search history from localStorage
        try {
          const savedHistory = localStorage.getItem('searchHistory');
          if (savedHistory) {
            searchHistory = JSON.parse(savedHistory).slice(0, 10); // Keep only last 10 searches
          }
        } catch (error) {
          console.warn('Failed to load search history:', error);
          searchHistory = [];
        }
        
        // Load recent items and bookmarks
        try {
          const savedRecent = localStorage.getItem('recentItems');
          if (savedRecent) {
            recentItems = JSON.parse(savedRecent).slice(0, 20); // Keep last 20 recent items
          }
        } catch (error) {
          console.warn('Failed to load recent items:', error);
          recentItems = [];
        }
        
        try {
          const savedBookmarks = localStorage.getItem('bookmarkedItems');
          if (savedBookmarks) {
            bookmarkedItems = JSON.parse(savedBookmarks);
          }
        } catch (error) {
          console.warn('Failed to load bookmarks:', error);
          bookmarkedItems = [];
        }
        
        if (window.logger) {
          window.logger.info('Search initialization completed', {
            totalItems: searchData.length,
            books: books.length,
            categories: categories.length,
            characters: characters.length,
            historyItems: searchHistory.length
          });
        }
        
      } catch (error) {
        const errorMessage = 'Search initialization failed: ' + error.message;
        console.error(errorMessage, error);
        
        // Log the error
        if (window.logger) {
          window.logger.error(errorMessage, { 
            error: error.message,
            stack: error.stack,
            component: 'search-init'
          });
        }
        
        if (window.telemetry) {
          window.telemetry.recordError(error, { component: 'search-initialization' });
        }
        
        // Fallback: show error message to user
        const searchContainer = document.querySelector('.search-container');
        if (searchContainer) {
          const errorDiv = document.createElement('div');
          errorDiv.style.cssText = 'background: #ff4444; color: white; padding: 0.5rem; border-radius: 4px; margin-bottom: 1rem; text-align: center;';
          errorDiv.textContent = 'Search functionality temporarily unavailable';
          searchContainer.appendChild(errorDiv);
        }
      }
    }

    // Search function
    function performSearch(query) {
      if (!query || query.length < 2) return [];
      
      try {
        const startTime = performance.now();
        const lowercaseQuery = query.toLowerCase();
        
        if (!searchData || !Array.isArray(searchData)) {
          throw new Error('Search data not properly initialized');
        }
        
        const results = searchData
          .map(item => {
            try {
              const score = calculateRelevance(item, lowercaseQuery);
              return { ...item, score };
            } catch (itemError) {
              if (window.logger) {
                window.logger.warn('Error calculating relevance for search item', { 
                  item: item.title || 'unknown', 
                  error: itemError.message 
                });
              }
              return { ...item, score: 0 };
            }
          })
          .filter(item => item.score > 0)
          .sort((a, b) => {
            // First sort by score
            if (b.score !== a.score) return b.score - a.score;
            
            // Then prioritize: books > characters > chapters > categories
            const typeOrder = { book: 1, character: 2, chapter: 3, category: 4 };
            return (typeOrder[a.type] || 5) - (typeOrder[b.type] || 5);
          })
          .slice(0, 10);
        
        const duration = performance.now() - startTime;
        
        // Log search with both logger and telemetry
        if (window.logger) {
          window.logger.search(query, results, duration);
        }
        if (window.telemetry) {
          window.telemetry.recordSearch(query, results.length, duration);
        }
        
        return results;
        
      } catch (error) {
        const errorMessage = 'Search operation failed: ' + error.message;
        console.error(errorMessage, error);
        
        // Log the error
        if (window.logger) {
          window.logger.error(errorMessage, { 
            query: query.substring(0, 50),
            error: error.message,
            component: 'search-perform'
          });
        }
        
        if (window.telemetry) {
          window.telemetry.recordError(error, { 
            component: 'search-operation',
            query_length: query.length 
          });
        }
        
        // Return empty results on error
        return [];
      }
    }

    // Add search query to history
    function addToSearchHistory(query, result) {
      if (!query || query.length < 2) return;
      
      const historyItem = {
        query: query,
        timestamp: Date.now(),
        resultType: result ? result.type : null,
        resultTitle: result ? result.title : null
      };
      
      // Remove existing entry for this query
      searchHistory = searchHistory.filter(item => item.query.toLowerCase() !== query.toLowerCase());
      
      // Add to beginning
      searchHistory.unshift(historyItem);
      
      // Keep only last 10 items
      searchHistory = searchHistory.slice(0, 10);
      
      // Save to localStorage
      try {
        localStorage.setItem('searchHistory', JSON.stringify(searchHistory));
      } catch (error) {
        console.warn('Failed to save search history:', error);
      }
    }

    // Get search history for display
    function getSearchHistory(currentQuery = '') {
      if (!searchHistory || searchHistory.length === 0) return [];
      
      // Filter out current query and show relevant history
      return searchHistory
        .filter(item => item.query.toLowerCase() !== currentQuery.toLowerCase())
        .slice(0, 5)
        .map(item => ({
          type: 'history',
          query: item.query,
          timestamp: item.timestamp,
          resultType: item.resultType,
          resultTitle: item.resultTitle,
          icon: 'â†»'
        }));
    }

    // Clear search history
    function clearSearchHistory() {
      searchHistory = [];
      try {
        localStorage.removeItem('searchHistory');
      } catch (error) {
        console.warn('Failed to clear search history:', error);
      }
      
      // Track history clear
      if (window.telemetry) {
        window.telemetry.recordUserAction('search-history-clear');
      }
    }

    // Recent items management
    function addToRecentItems(pageData) {
      if (!pageData || !pageData.url) return;
      
      const recentItem = {
        ...pageData,
        timestamp: Date.now(),
        visitCount: 1
      };
      
      // Check if item already exists
      const existingIndex = recentItems.findIndex(item => item.url === pageData.url);
      if (existingIndex !== -1) {
        // Update existing item
        recentItems[existingIndex] = {
          ...recentItems[existingIndex],
          timestamp: Date.now(),
          visitCount: (recentItems[existingIndex].visitCount || 1) + 1
        };
      } else {
        // Add new item to beginning
        recentItems.unshift(recentItem);
      }
      
      // Keep only last 20 items
      recentItems = recentItems.slice(0, 20);
      
      // Save to localStorage
      try {
        localStorage.setItem('recentItems', JSON.stringify(recentItems));
      } catch (error) {
        console.warn('Failed to save recent items:', error);
      }
    }

    // Bookmark management
    function toggleBookmark(pageData) {
      if (!pageData || !pageData.url) return false;
      
      const existingIndex = bookmarkedItems.findIndex(item => item.url === pageData.url);
      
      if (existingIndex !== -1) {
        // Remove bookmark
        bookmarkedItems.splice(existingIndex, 1);
        
        // Track unbookmark
        if (window.telemetry) {
          window.telemetry.recordUserAction('bookmark-remove', pageData.url, {
            type: pageData.type,
            title: pageData.title
          });
        }
        
        updateBookmarkButton(false);
        return false;
      } else {
        // Add bookmark
        const bookmarkItem = {
          ...pageData,
          bookmarkedAt: Date.now()
        };
        bookmarkedItems.unshift(bookmarkItem);
        
        // Track bookmark
        if (window.telemetry) {
          window.telemetry.recordUserAction('bookmark-add', pageData.url, {
            type: pageData.type,
            title: pageData.title
          });
        }
        
        updateBookmarkButton(true);
        return true;
      }
      
      // Save to localStorage
      try {
        localStorage.setItem('bookmarkedItems', JSON.stringify(bookmarkedItems));
      } catch (error) {
        console.warn('Failed to save bookmarks:', error);
      }
    }

    function isBookmarked(url) {
      return bookmarkedItems.some(item => item.url === url);
    }

    function updateBookmarkButton(isBookmarked) {
      const bookmarkBtn = document.querySelector('.bookmark-btn');
      if (bookmarkBtn) {
        const icon = bookmarkBtn.querySelector('.bookmark-icon');
        const text = bookmarkBtn.querySelector('.bookmark-text');
        
        if (isBookmarked) {
          icon.textContent = 'â˜…';
          text.textContent = 'Bookmarked';
          bookmarkBtn.classList.add('bookmarked');
          bookmarkBtn.title = 'Remove bookmark';
        } else {
          icon.textContent = 'â˜†';
          text.textContent = 'Bookmark';
          bookmarkBtn.classList.remove('bookmarked');
          bookmarkBtn.title = 'Add bookmark';
        }
      }
    }

    function clearAllRecentItems() {
      recentItems = [];
      try {
        localStorage.removeItem('recentItems');
      } catch (error) {
        console.warn('Failed to clear recent items:', error);
      }
      
      // Track clear recent
      if (window.telemetry) {
        window.telemetry.recordUserAction('recent-clear');
      }
    }

    function clearAllBookmarks() {
      bookmarkedItems = [];
      try {
        localStorage.removeItem('bookmarkedItems');
      } catch (error) {
        console.warn('Failed to clear bookmarks:', error);
      }
      
      updateBookmarkButton(false);
      
      // Track clear bookmarks
      if (window.telemetry) {
        window.telemetry.recordUserAction('bookmarks-clear');
      }
      
      updateRecentsBookmarksDisplay();
    }

    // Recents/Bookmarks panel management
    function toggleRecentsBookmarks() {
      const panel = document.getElementById('recentsBookmarksPanel');
      const isVisible = panel.classList.contains('visible');
      
      if (isVisible) {
        panel.classList.remove('visible');
      } else {
        panel.classList.add('visible');
        updateRecentsBookmarksDisplay();
      }
      
      // Track panel usage
      if (window.telemetry) {
        window.telemetry.recordUserAction('recents-bookmarks-toggle', isVisible ? 'close' : 'open');
      }
    }

    // Close recents panel with click away
    function closeRecentsBookmarksPanel() {
      const panel = document.getElementById('recentsBookmarksPanel');
      if (panel && panel.classList.contains('visible')) {
        panel.classList.remove('visible');
      }
    }

    function switchTab(tabName) {
      const tabs = document.querySelectorAll('.tab-btn');
      const contents = document.querySelectorAll('.tab-content');
      
      tabs.forEach(tab => tab.classList.remove('active'));
      contents.forEach(content => content.classList.remove('active'));
      
      document.getElementById(tabName + 'Tab').classList.add('active');
      document.getElementById(tabName + 'Content').classList.add('active');
      
      // Track tab switch
      if (window.telemetry) {
        window.telemetry.recordUserAction('recents-bookmarks-tab-switch', tabName);
      }
    }

    function updateRecentsBookmarksDisplay() {
      // Update counts
      document.getElementById('bookmarksCount').textContent = bookmarkedItems.length;
      document.getElementById('recentCount').textContent = recentItems.length;
      
      // Update bookmarks list
      const bookmarksList = document.getElementById('bookmarksList');
      if (bookmarkedItems.length === 0) {
        bookmarksList.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">â˜…</div>
            <p>No bookmarks yet</p>
            <small>Bookmark pages to access them quickly later</small>
          </div>
        `;
      } else {
        bookmarksList.innerHTML = bookmarkedItems.map(item => `
          <div class="quick-access-item">
            <a href="${item.url}" class="item-link" onclick="navigateFromQuickAccess('${item.url}', '${item.type}', '${item.title}')">
              <div class="item-icon">${getItemIcon(item.type)}</div>
              <div class="item-content">
                <div class="item-title">${item.title}</div>
                <div class="item-meta">${item.type} â€¢ ${getTimeAgo(item.bookmarkedAt)}</div>
              </div>
            </a>
            <button class="remove-item-btn" onclick="toggleBookmark({url: '${item.url}', type: '${item.type}', title: '${item.title.replace(/'/g, "\\'")}'})" title="Remove bookmark">
              Ã—
            </button>
          </div>
        `).join('');
      }
      
      // Update recent list
      const recentsList = document.getElementById('recentsList');
      if (recentItems.length === 0) {
        recentsList.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">â†»</div>
            <p>No recent items</p>
            <small>Pages you visit will appear here</small>
          </div>
        `;
      } else {
        recentsList.innerHTML = recentItems.map(item => `
          <div class="quick-access-item">
            <a href="${item.url}" class="item-link" onclick="navigateFromQuickAccess('${item.url}', '${item.type}', '${item.title}')">
              <div class="item-icon">${getItemIcon(item.type)}</div>
              <div class="item-content">
                <div class="item-title">${item.title}</div>
                <div class="item-meta">${item.type}${item.visitCount > 1 ? ' â€¢ ' + item.visitCount + ' visits' : ''} â€¢ ${getTimeAgo(item.timestamp)}</div>
              </div>
            </a>
            <button class="bookmark-quick-btn" onclick="toggleBookmark({url: '${item.url}', type: '${item.type}', title: '${item.title.replace(/'/g, "\\'")}'})" title="${isBookmarked(item.url) ? 'Remove bookmark' : 'Add bookmark'}">
              ${isBookmarked(item.url) ? 'â˜…' : 'â˜†'}
            </button>
          </div>
        `).join('');
      }
    }

    function getItemIcon(type) {
      const icons = {
        book: 'â–¦',
        character: 'â—¯',
        category: 'â—',
        chapter: 'â–¡',
        'gospel-theme': 'âˆ¿',
        default: 'â–¡'
      };
      return icons[type] || icons.default;
    }

    function navigateFromQuickAccess(url, type, title) {
      // Track navigation from quick access
      if (window.telemetry) {
        window.telemetry.recordNavigation('quick-access-click', url, {
          type: type,
          title: title
        });
      }
      
      // Close panel
      toggleRecentsBookmarks();
    }

    function clearAllRecentItems() {
      recentItems = [];
      try {
        localStorage.removeItem('recentItems');
      } catch (error) {
        console.warn('Failed to clear recent items:', error);
      }
      
      updateRecentsBookmarksDisplay();
      
      // Track clear recent
      if (window.telemetry) {
        window.telemetry.recordUserAction('recent-clear');
      }
    }

    function clearAllBookmarks() {
      bookmarkedItems = [];
      try {
        localStorage.removeItem('bookmarkedItems');
      } catch (error) {
        console.warn('Failed to clear bookmarks:', error);
      }
      
      updateBookmarkButton(false);
      updateRecentsBookmarksDisplay();
      
      // Track clear bookmarks
      if (window.telemetry) {
        window.telemetry.recordUserAction('bookmarks-clear');
      }
    }

    // Cross-reference system
    function processTextForCrossReferences(text, currentBook, currentChapter) {
      if (!crossReferences || !text) return text;
      
      let processedText = text;
      
      // Pattern to match biblical references like "Genesis 1:1", "Romans 8:28", "1 Corinthians 13"
      const referencePattern = /\b(\d?\s?\w+)\s+(\d+)(?::(\d+(?:-\d+)?))?\b/g;
      
      processedText = processedText.replace(referencePattern, (match, bookName, chapter, verse) => {
        const cleanBookName = bookName.toLowerCase().replace(/\s+/g, '-');
        const bookSlug = getBookSlugFromName(cleanBookName);
        
        if (bookSlug && bookSlug !== currentBook) {
          const linkUrl = `/books/${bookSlug}/#chapter-${chapter}`;
          const linkText = verse ? `${bookName} ${chapter}:${verse}` : `${bookName} ${chapter}`;
          return `<a href="${linkUrl}" class="cross-reference-link" title="Read ${linkText}">${match}</a>`;
        }
        
        return match;
      });
      
      // Add thematic cross-references
      const themes = ['covenant', 'messiah', 'salvation', 'resurrection', 'faith', 'grace'];
      themes.forEach(theme => {
        const themePattern = new RegExp(`\\b${theme}\\b`, 'gi');
        if (themePattern.test(text) && crossReferences.thematicReferences[theme]) {
          // Add subtle indicator for thematic connections
          processedText = processedText.replace(themePattern, (match) => {
            return `<span class="theme-reference" data-theme="${theme}" title="Related passages about ${theme}">${match}</span>`;
          });
        }
      });
      
      return processedText;
    }

    function getBookSlugFromName(bookName) {
      const bookMappings = {
        'genesis': 'genesis',
        'exodus': 'exodus',
        'leviticus': 'leviticus',
        'numbers': 'numbers',
        'deuteronomy': 'deuteronomy',
        'joshua': 'joshua',
        'judges': 'judges',
        'ruth': 'ruth',
        '1-samuel': '1-samuel',
        '2-samuel': '2-samuel',
        '1-kings': '1-kings',
        '2-kings': '2-kings',
        'psalms': 'psalms',
        'proverbs': 'proverbs',
        'ecclesiastes': 'ecclesiastes',
        'isaiah': 'isaiah',
        'jeremiah': 'jeremiah',
        'ezekiel': 'ezekiel',
        'daniel': 'daniel',
        'matthew': 'matthew',
        'mark': 'mark',
        'luke': 'luke',
        'john': 'john',
        'acts': 'acts',
        'romans': 'romans',
        '1-corinthians': '1-corinthians',
        '2-corinthians': '2-corinthians',
        'galatians': 'galatians',
        'ephesians': 'ephesians',
        'philippians': 'philippians',
        'colossians': 'colossians',
        '1-thessalonians': '1-thessalonians',
        '2-thessalonians': '2-thessalonians',
        'hebrews': 'hebrews',
        'james': 'james',
        '1-peter': '1-peter',
        '2-peter': '2-peter',
        '1-john': '1-john',
        'revelation': 'revelation'
      };
      
      return bookMappings[bookName.toLowerCase().replace(/\s+/g, '-')];
    }

    function getCrossReferencesForChapter(bookSlug, chapter) {
      if (!crossReferences) return [];
      
      const chapterKey = `${bookSlug}-${chapter}`;
      const chapterRefs = crossReferences.chapterReferences[chapterKey] || [];
      
      // Also get book-level references
      const bookRefs = crossReferences.bookReferences[bookSlug]?.references || [];
      
      // Combine and format
      return [...chapterRefs, ...bookRefs].map(ref => ({
        ...ref,
        url: `/books/${ref.book}/#chapter-${ref.chapter}`
      }));
    }

    function getThematicReferences(theme) {
      if (!crossReferences || !crossReferences.thematicReferences[theme]) return [];
      
      return crossReferences.thematicReferences[theme].map(ref => ({
        ...ref,
        url: ref.verse 
          ? `/books/${ref.book}/#chapter-${ref.chapter}` 
          : `/books/${ref.book}/#chapter-${ref.chapter}`
      }));
    }

    function displayCrossReferences(container, references) {
      if (!references || references.length === 0) return;
      
      const crossRefHtml = `
        <div class="cross-references-section">
          <h4>Related Passages</h4>
          <div class="cross-references-list">
            ${references.slice(0, 6).map(ref => `
              <a href="${ref.url}" class="cross-reference-item" title="${ref.text}">
                <div class="cross-ref-book">${ref.book.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase())} ${ref.chapter}${ref.verse ? ':' + ref.verse : ''}</div>
                <div class="cross-ref-connection">${ref.connection}</div>
                <div class="cross-ref-text">${ref.text}</div>
              </a>
            `).join('')}
          </div>
          ${references.length > 6 ? `<button class="show-more-refs" onclick="toggleMoreReferences()">Show ${references.length - 6} more</button>` : ''}
        </div>
      `;
      
      container.innerHTML += crossRefHtml;
    }

    // Generate autocomplete suggestions
    function generateAutocomplete(query) {
      if (!query || query.length < 1) return [];
      
      const suggestions = [];
      const queryLower = query.toLowerCase();
      
      // Extract common search patterns and suggest completions
      const commonTerms = {
        books: ['Genesis', 'Exodus', 'Leviticus', 'Numbers', 'Deuteronomy', 'Joshua', 'Judges', 'Ruth', 'Samuel', 'Kings', 'Chronicles', 'Ezra', 'Nehemiah', 'Esther', 'Job', 'Psalms', 'Proverbs', 'Ecclesiastes', 'Isaiah', 'Jeremiah', 'Ezekiel', 'Daniel', 'Matthew', 'Mark', 'Luke', 'John', 'Acts', 'Romans', 'Corinthians', 'Galatians', 'Ephesians', 'Philippians', 'Colossians', 'Thessalonians', 'Timothy', 'Titus', 'Philemon', 'Hebrews', 'James', 'Peter', 'Revelation'],
        characters: ['Abraham', 'Moses', 'David', 'Solomon', 'Jesus', 'Paul', 'Peter', 'John', 'Mary', 'Joseph', 'Daniel', 'Noah', 'Isaac', 'Jacob', 'Joshua', 'Samuel', 'Elijah', 'Elisha', 'Isaiah', 'Jeremiah', 'Ezekiel'],
        topics: ['salvation', 'faith', 'love', 'grace', 'mercy', 'kingdom', 'covenant', 'prophecy', 'redemption', 'forgiveness', 'resurrection', 'cross', 'temple', 'sacrifice'],
        categories: ['Law', 'History', 'Poetry', 'Prophets', 'Gospels', 'Letters', 'Revelation']
      };
      
      // Find matching suggestions
      Object.entries(commonTerms).forEach(([category, terms]) => {
        terms.forEach(term => {
          if (term.toLowerCase().startsWith(queryLower) && term.toLowerCase() !== queryLower) {
            suggestions.push({
              type: 'suggestion',
              query: term,
              category: category,
              icon: category === 'books' ? 'â–¦' : category === 'characters' ? 'â—¯' : category === 'topics' ? 'â—Š' : 'â—'
            });
          }
        });
      });
      
      // Limit to 5 suggestions, prioritize books and characters
      return suggestions
        .sort((a, b) => {
          const order = { books: 1, characters: 2, topics: 3, categories: 4 };
          return order[a.category] - order[b.category];
        })
        .slice(0, 5);
    }

    // Calculate relevance score
    function calculateRelevance(item, query) {
      const content = item.content.toLowerCase();
      const title = item.title.toLowerCase();
      
      let score = 0;
      
      // Perfect title match gets highest score
      if (title === query) {
        score += 200;
        // Boost books and characters for exact matches
        if (item.type === 'book') score += 50;
        if (item.type === 'character') score += 40;
      }
      
      // Title starts with query
      if (title.startsWith(query)) {
        score += 150;
      }
      
      // Title contains query
      if (title.includes(query)) {
        score += 100;
      }
      
      // Content match gets medium score
      if (content.includes(query)) {
        score += 50;
      }
      
      // Word boundary matches get bonus
      const words = query.split(' ');
      words.forEach(word => {
        if (word.length > 2) {
          const regex = new RegExp('\\b' + word, 'i');
          if (regex.test(title)) score += 30;
          if (regex.test(content)) score += 15;
        }
      });
      
      // Type-based bonuses for better user experience
      if (item.type === 'book') score += 10;  // Slightly prioritize books
      if (item.type === 'character') score += 5;  // Then characters
      
      return score;
    }

    // Highlight search terms
    function highlightText(text, query) {
      if (!query) return text;
      const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      return text.replace(regex, '<span class="search-highlight">$1</span>');
    }

    // Show loading state
    function showLoadingState() {
      const resultsContainer = document.getElementById('searchResults');
      const searchInput = document.getElementById('searchInput');
      
      // Add loading class to search box
      const searchBox = searchInput.closest('.search-box');
      searchBox.classList.add('searching');
      
      // Show loading spinner
      resultsContainer.innerHTML = `
        <div class="search-loading">
          <div class="search-spinner"></div>
          <span>Searching...</span>
        </div>
      `;
      resultsContainer.style.display = 'block';
    }
    
    // Hide loading state
    function hideLoadingState() {
      const searchInput = document.getElementById('searchInput');
      const searchBox = searchInput.closest('.search-box');
      searchBox.classList.remove('searching');
    }

    // Display search results with autocomplete and history
    function displayResults(results, query) {
      const resultsContainer = document.getElementById('searchResults');
      
      // Hide loading state
      hideLoadingState();
      
      let html = '';
      
      // Show search history when query is empty or very short
      const history = getSearchHistory(query);
      if ((!query || query.length < 2) && history.length > 0) {
        html += '<div class="search-separator">Recent Searches <button class="clear-history-btn" onclick="clearSearchHistory()" title="Clear search history">Ã—</button></div>';
        html += history.map(item => {
          const timeAgo = getTimeAgo(item.timestamp);
          const resultInfo = item.resultTitle ? ` â†’ ${item.resultTitle}` : '';
          return `
            <div class="search-suggestion-item search-history-item" onclick="selectSuggestion('${item.query}')">
              <div class="suggestion-icon">${item.icon}</div>
              <div class="suggestion-text">
                <span class="suggestion-query">${item.query}</span>
                <span class="suggestion-category">${timeAgo}${resultInfo}</span>
              </div>
            </div>
          `;
        }).join('');
      }
      
      // Show search results
      if (results.length > 0) {
        if (html) html += '<div class="search-separator">Results</div>';
        html += results.map(result => `
          <div class="search-result-item" data-type="${result.type}" onclick="handleSearchResultClick('${result.url}', '${result.type}', '${result.title.replace(/'/g, "\\'")}')">
            <div class="search-result-header">
              <div class="search-result-title">${highlightText(result.title, query)}</div>
              <div class="search-result-type">${result.typeLabel || result.type}</div>
            </div>
            <div class="search-result-snippet">${highlightText(result.subtitle, query)}</div>
          </div>
        `).join('');
      }
      
      // Add autocomplete suggestions if query is present and results are few
      const suggestions = generateAutocomplete(query);
      if (query && suggestions.length > 0 && (results.length < 3 || query.length < 3)) {
        if (results.length > 0 || html) {
          html += '<div class="search-separator">Suggestions</div>';
        }
        
        html += suggestions.map(suggestion => `
          <div class="search-suggestion-item" onclick="selectSuggestion('${suggestion.query}')">
            <div class="suggestion-icon">${suggestion.icon}</div>
            <div class="suggestion-text">
              <span class="suggestion-query">${highlightText(suggestion.query, query)}</span>
              <span class="suggestion-category">${suggestion.category}</span>
            </div>
          </div>
        `).join('');
      }
      
      // Show no results message if nothing found and query is present
      if (query && results.length === 0 && suggestions.length === 0 && history.length === 0) {
        html = `
          <div class="search-result-item no-results">
            <div class="no-results-icon">âŒ•</div>
            <div>No results found for "${query}"</div>
            <div class="search-suggestion">Try searching for book names, characters, or topics</div>
          </div>
        `;
      }
      
      resultsContainer.innerHTML = html;
      resultsContainer.style.display = html ? 'block' : 'none';
    }

    // Helper function to format time ago
    function getTimeAgo(timestamp) {
      const now = Date.now();
      const diff = now - timestamp;
      const minutes = Math.floor(diff / 60000);
      const hours = Math.floor(diff / 3600000);
      const days = Math.floor(diff / 86400000);
      
      if (days > 0) return `${days}d ago`;
      if (hours > 0) return `${hours}h ago`;
      if (minutes > 0) return `${minutes}m ago`;
      return 'just now';
    }
    
    // Handle suggestion selection
    function selectSuggestion(query) {
      const searchInput = document.getElementById('searchInput');
      searchInput.value = query;
      searchInput.focus();
      
      // Trigger search with filters
      const results = performSearchWithFilters(query);
      displayResults(results, query);
      
      // Track suggestion usage
      if (window.telemetry) {
        window.telemetry.recordUserAction('search-suggestion-select', query, {
          original_query: searchInput.value,
          suggested_query: query
        });
      }
    }

    // Toggle search filters
    function toggleSearchFilters() {
      const filtersPanel = document.getElementById('searchFilters');
      const toggleButton = document.getElementById('searchFiltersToggle');
      const isVisible = filtersPanel.style.display === 'block';
      
      if (isVisible) {
        filtersPanel.style.opacity = '0';
        filtersPanel.style.transform = 'translateY(-10px)';
        setTimeout(() => {
          filtersPanel.style.display = 'none';
        }, 300);
      } else {
        filtersPanel.style.display = 'block';
        filtersPanel.style.opacity = '0';
        filtersPanel.style.transform = 'translateY(-10px)';
        setTimeout(() => {
          filtersPanel.style.opacity = '1';
          filtersPanel.style.transform = 'translateY(0)';
        }, 10);
      }
      
      toggleButton.classList.toggle('active', !isVisible);
      
      // Track filter panel usage
      if (window.telemetry) {
        window.telemetry.recordUserAction('search-filters-toggle', !isVisible ? 'open' : 'close');
      }
    }
    
    // Show search filters dynamically
    function showSearchFilters() {
      const filtersPanel = document.getElementById('searchFilters');
      const toggleButton = document.getElementById('searchFiltersToggle');
      
      if (filtersPanel && filtersPanel.style.display === 'none') {
        filtersPanel.style.display = 'block';
        filtersPanel.style.opacity = '0';
        filtersPanel.style.transform = 'translateY(-10px)';
        
        setTimeout(() => {
          filtersPanel.style.opacity = '1';
          filtersPanel.style.transform = 'translateY(0)';
        }, 10);
        
        toggleButton.classList.add('active');
      }
    }
    
    // Hide search filters dynamically
    function hideSearchFilters() {
      const filtersPanel = document.getElementById('searchFilters');
      const toggleButton = document.getElementById('searchFiltersToggle');
      const searchInput = document.getElementById('searchInput');
      
      // Don't hide if user is actively searching or filters are applied
      if (searchInput && searchInput.value.trim().length > 0) return;
      if (hasActiveGlobalFilters()) return;
      
      // Don't hide if user is hovering over filters
      if (filtersPanel && filtersPanel.hasAttribute('data-hovering')) return;
      
      setTimeout(() => {
        if (document.activeElement !== searchInput && !filtersPanel.contains(document.activeElement) && !filtersPanel.hasAttribute('data-hovering')) {
          filtersPanel.style.opacity = '0';
          filtersPanel.style.transform = 'translateY(-10px)';
          
          setTimeout(() => {
            if (filtersPanel.style.opacity === '0') {
              filtersPanel.style.display = 'none';
              toggleButton.classList.remove('active');
            }
          }, 300);
        }
      }, 150);
    }
    
    // Check if any global filters are active
    function hasActiveGlobalFilters() {
      const checkboxes = document.querySelectorAll('#searchFilters input[type="checkbox"]:checked');
      const allCheckboxes = document.querySelectorAll('#searchFilters input[type="checkbox"]');
      return checkboxes.length < allCheckboxes.length;
    }

    // Clear all filters
    function clearAllFilters() {
      const checkboxes = document.querySelectorAll('#searchFilters input[type="checkbox"]');
      checkboxes.forEach(checkbox => {
        checkbox.checked = true; // Reset to show all
      });
      
      // Trigger search refresh if there's a query
      const searchInput = document.getElementById('searchInput');
      if (searchInput.value.trim()) {
        const results = performSearchWithFilters(searchInput.value.trim());
        displayResults(results, searchInput.value.trim());
      }
      
      // Track filter clear
      if (window.telemetry) {
        window.telemetry.recordUserAction('search-filters-clear');
      }
    }

    // Get active filters
    function getActiveFilters() {
      const filters = {
        contentType: [],
        testament: [],
        category: []
      };
      
      document.querySelectorAll('#searchFilters input[type="checkbox"]:checked').forEach(checkbox => {
        const filterType = checkbox.name;
        const filterValue = checkbox.value;
        if (filters[filterType]) {
          filters[filterType].push(filterValue);
        }
      });
      
      return filters;
    }

    // Perform search with filters applied
    function performSearchWithFilters(query) {
      if (!query || query.length < 1) return [];
      
      const filters = getActiveFilters();
      const baseResults = performSearch(query);
      
      // Apply filters
      return baseResults.filter(item => {
        // Content type filter
        if (filters.contentType.length > 0 && !filters.contentType.includes(item.type)) {
          return false;
        }
        
        // Testament filter (for books and characters)
        if (filters.testament.length > 0 && item.testament && !filters.testament.includes(item.testament)) {
          return false;
        }
        
        // Category filter (for books)
        if (filters.category.length > 0 && item.category && !filters.category.includes(item.category)) {
          return false;
        }
        
        return true;
      });
    }

    // Handle search result clicks
    function handleSearchResultClick(url, type, title) {
      try {
        if (!url || typeof url !== 'string') {
          throw new Error('Invalid URL provided for navigation');
        }
        
        const searchInput = document.getElementById('searchInput');
        const searchQuery = searchInput ? searchInput.value : 'unknown';
        
        // Add to search history
        if (searchQuery && searchQuery !== 'unknown') {
          addToSearchHistory(searchQuery, { type, title });
        }
        
        // Log user action
        if (window.logger) {
          window.logger.userAction('search-result-click', { 
            url, 
            type, 
            title,
            searchQuery 
          });
        }
        
        // Record navigation
        if (window.telemetry) {
          window.telemetry.recordNavigation('search-click', url, { 
            result_type: type,
            result_title: title 
          });
        }
        
        // Clear search results
        const searchResults = document.getElementById('searchResults');
        if (searchResults) {
          searchResults.style.display = 'none';
        }
        
        // For character results, add extra context
        if (type === 'character') {
          // Add slight delay to allow navigation start, then clear search
          setTimeout(() => {
            if (searchInput) {
              searchInput.blur();
            }
          }, 100);
        }
        
        // Navigate to the page
        window.location.href = url;
        
      } catch (error) {
        const errorMessage = 'Navigation failed: ' + error.message;
        console.error(errorMessage, error);
        
        // Log the error
        if (window.logger) {
          window.logger.error(errorMessage, { 
            url,
            type,
            title,
            error: error.message,
            component: 'search-navigation'
          });
        }
        
        if (window.telemetry) {
          window.telemetry.recordError(error, { 
            component: 'search-result-click',
            url: url 
          });
        }
        
        // Show user-friendly error
        alert('Sorry, there was an error navigating to that page. Please try again.');
      }
    }

    // Enhanced search system state with global search integration
    let searchModulesReady = false;
    let searchDataReady = false;
    let globalSearchReady = false;
    let searchInput, searchResults;

    // Search input handler
    document.addEventListener('DOMContentLoaded', function() {
      // Cache DOM elements
      searchInput = document.getElementById('searchInput');
      searchResults = document.getElementById('searchResults');
      
      // Update keyboard shortcut hint based on platform
      const shortcutHint = document.getElementById('searchShortcut');
      const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
      shortcutHint.textContent = isMac ? 'âŒ˜K' : 'Ctrl+K';

      // Initialize search data
      initializeSearchData();
      
      // Set up search input state management
      setupSearchInputHandlers();
      
      // Integrate with global search when available
      const integrateGlobalSearch = () => {
        if (window.globalSearch && window.enhanceSearchInput) {
          window.enhanceSearchInput(searchInput);
          console.log('[Search] Integrated with global search');
          return true;
        }
        return false;
      };
      
      // Try integration multiple times
      setTimeout(() => integrateGlobalSearch(), 100);
      setTimeout(() => integrateGlobalSearch(), 500);
      setTimeout(() => integrateGlobalSearch(), 1000);
    });

    // Listen for global search being loaded
    document.addEventListener('globalSearchLoaded', function() {
      globalSearchReady = true;
      console.log('[Search] Global search loaded successfully');
      enableGlobalSearchIntegration();
    });

    // Listen for search modules being loaded
    document.addEventListener('searchModulesLoaded', function() {
      searchModulesReady = true;
      console.log('[Search] Search modules loaded successfully');
      enableSearchIfReady();
    });

    // Handle search modules loading failure
    document.addEventListener('searchModulesLoadFailed', function(event) {
      console.error('[Search] Search modules failed to load:', event.detail);
      showSearchError('Search modules failed to load');
    });

    // Fallback timeout in case modules never load
    setTimeout(function() {
      if (!searchModulesReady && !globalSearchReady) {
        console.warn('[Search] Search modules timeout - enabling basic search');
        searchModulesReady = true; // Enable basic functionality
        enableSearchIfReady();
      }
    }, 3000); // 3 second timeout

    async function initializeSearchData() {
      try {
        await initializeSearch();
        searchDataReady = true;
        console.log('[Search] Search data initialized');
        enableSearchIfReady();
        
        // Share search data with global search
        if (window.globalSearch && searchData) {
          console.log('[Search] Sharing search data with global search:', searchData.length, 'items');
          window.globalSearch.searchData = searchData;
          window.globalSearch.isInitialized = true;
          document.dispatchEvent(new CustomEvent('searchDataLoaded', { detail: searchData }));
        }
        
        // Also make searchData globally available
        window.searchData = searchData;
      } catch (error) {
        console.error('[Search] Failed to initialize search data:', error);
        showSearchError('Search data failed to load');
      }
    }

    function enableGlobalSearchIntegration() {
      if (globalSearchReady && searchInput && window.enhanceSearchInput) {
        console.log('[Search] Enabling global search integration');
        window.enhanceSearchInput(searchInput);
        searchInput.disabled = false;
        searchInput.placeholder = 'Search books, characters, topics...';
        console.log('[Search] Global search integration enabled');
        
        // Debug the search data
        if (window.debugGlobalSearch) {
          setTimeout(() => window.debugGlobalSearch(), 1000);
        }
      } else {
        console.log('[Search] Global search integration failed - missing:', {
          globalSearchReady,
          searchInput: !!searchInput,
          enhanceSearchInput: !!window.enhanceSearchInput
        });
      }
    }

    function enableSearchIfReady() {
      if ((searchModulesReady || globalSearchReady) && searchDataReady && searchInput) {
        searchInput.disabled = false;
        searchInput.placeholder = globalSearchReady ? 
          'Search books, characters, topics...' : 
          'Search books, chapters, or summaries...';
        console.log('[Search] Search functionality enabled');
      }
    }

    function showSearchError(message) {
      if (searchInput) {
        searchInput.placeholder = 'Search temporarily unavailable';
        searchInput.disabled = true;
        console.warn('[Search] ' + message);
      }
    }

    function setupSearchInputHandlers() {
      if (!searchInput || !searchResults) return;
      
      // Initially disable search until modules load
      searchInput.disabled = true;
      searchInput.placeholder = 'Loading search...';
      
      searchInput.addEventListener('input', function() {
        // Guard clause: only process search if modules and data are ready
        if (!searchModulesReady || !searchDataReady || this.disabled) {
          console.log('[Search] Search not ready yet, ignoring input');
          return;
        }

        const query = this.value.trim();
        
        clearTimeout(searchTimeout);
        
        try {
          if (query.length === 0) {
            // Hide results if query is empty
            searchResults.style.display = 'none';
            if (typeof hideLoadingState === 'function') hideLoadingState();
          } else if (query.length === 1) {
            // Show immediate autocomplete suggestions for single character
            if (typeof generateAutocomplete === 'function') {
              const suggestions = generateAutocomplete(query);
              if (suggestions.length > 0 && typeof displayResults === 'function') {
                displayResults([], query);
              }
            }
          } else if (query.length >= 2) {
            // Show loading state immediately for longer queries
            if (typeof showLoadingState === 'function') showLoadingState();
          
            searchTimeout = setTimeout(() => {
              try {
                if (typeof performSearchWithFilters === 'function' && typeof displayResults === 'function') {
                  const results = performSearchWithFilters(query);
                  displayResults(results, query);
                } else {
                  console.warn('[Search] Search functions not available');
                  showSearchError('Search functions not loaded');
                }
              } catch (searchError) {
                console.error('[Search] Error performing search:', searchError);
                showSearchError('Search error occurred');
              }
            }, 200);
          }
        } catch (error) {
          console.error('[Search] Error in search input handler:', error);
          showSearchError('Search input error');
        }
      });
    }
      
    // Hide results when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('.search-box')) {
          searchResults.style.display = 'none';
        }
      });

      // Global click-away handling for side panels
      document.addEventListener('click', function(e) {
        // Close recents/bookmarks panel if clicking outside
        if (!e.target.closest('.recents-bookmarks-panel') && !e.target.closest('.recents-bookmarks-toggle')) {
          closeRecentsBookmarksPanel();
        }
        
        // Close font size panel if clicking outside
        if (!e.target.closest('.font-size-panel') && !e.target.closest('.font-size-toggle')) {
          closeFontSizePanel();
        }
        
        // Close search filters if clicking outside
        if (!e.target.closest('.search-filters') && !e.target.closest('.search-filters-toggle')) {
          const filtersPanel = document.getElementById('searchFilters');
          if (filtersPanel && filtersPanel.style.display === 'block') {
            hideSearchFilters();
          }
        }
      });
      
      // Show results when focusing search input
      searchInput.addEventListener('focus', function() {
        const query = this.value.trim();
        if (query) {
          const results = performSearchWithFilters(query);
          displayResults(results, query);
        } else {
          // Show search history when focusing empty search
          displayResults([], '');
        }
        
        // Show filters on focus
        showSearchFilters();
      });
      
      // Hide filters when blurring search input
      searchInput.addEventListener('blur', function() {
        hideSearchFilters();
      });
      
      // Add hover protection to search filters
      const globalFiltersPanel = document.getElementById('searchFilters');
      if (globalFiltersPanel) {
        globalFiltersPanel.addEventListener('mouseenter', function() {
          this.setAttribute('data-hovering', 'true');
        });
        
        globalFiltersPanel.addEventListener('mouseleave', function() {
          this.removeAttribute('data-hovering');
          hideSearchFilters();
        });
        
        // Show filters when user starts typing
        searchInput.addEventListener('input', function() {
          if (this.value.trim().length > 0) {
            showSearchFilters();
          }
        });
      }
      
      // Initialize checked classes for browsers without :has() support
      document.querySelectorAll('#searchFilters input[type="checkbox"]').forEach(checkbox => {
        const label = checkbox.closest('.filter-checkbox');
        if (label && checkbox.checked) {
          label.classList.add('checked');
        }
      });
      
      // Add filter change listeners
      document.querySelectorAll('#searchFilters input[type="checkbox"]').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          // Add checked class for browsers without :has() support
          const label = this.closest('.filter-checkbox');
          if (label) {
            if (this.checked) {
              label.classList.add('checked');
            } else {
              label.classList.remove('checked');
            }
          }
          // Update filter toggle button to show active state
          const toggleButton = document.getElementById('searchFiltersToggle');
          const allCheckboxes = document.querySelectorAll('#searchFilters input[type="checkbox"]');
          const checkedCheckboxes = document.querySelectorAll('#searchFilters input[type="checkbox"]:checked');
          const hasFiltersApplied = checkedCheckboxes.length < allCheckboxes.length;
          
          toggleButton.classList.toggle('has-filters', hasFiltersApplied);
          
          // Re-run search if there's a query
          const searchInput = document.getElementById('searchInput');
          if (searchInput.value.trim()) {
            const results = performSearchWithFilters(searchInput.value.trim());
            displayResults(results, searchInput.value.trim());
          }
          
          // Track filter usage
          if (window.telemetry) {
            window.telemetry.recordUserAction('search-filter-change', this.name, {
              value: this.value,
              checked: this.checked
            });
          }
        });
      });
      
      // Global keyboard shortcuts
      document.addEventListener('keydown', function(e) {
        // Cmd/Ctrl + K to focus search
        if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
          e.preventDefault();
          searchInput.focus();
          searchInput.select();
          
          // Track shortcut usage
          if (window.telemetry) {
            window.telemetry.recordUserAction('keyboard-shortcut', 'search-focus', {
              shortcut: (e.metaKey ? 'Cmd' : 'Ctrl') + '+K'
            });
          }
        }
        
        // / to focus search (like GitHub)
        if (e.key === '/' && !e.target.closest('input, textarea, [contenteditable]')) {
          e.preventDefault();
          searchInput.focus();
          
          // Track shortcut usage
          if (window.telemetry) {
            window.telemetry.recordUserAction('keyboard-shortcut', 'search-focus', {
              shortcut: '/'
            });
          }
        }
      });
      
      // Keyboard navigation within search results and suggestions
      searchInput.addEventListener('keydown', function(e) {
        const items = searchResults.querySelectorAll('.search-result-item, .search-suggestion-item');
        const selected = searchResults.querySelector('.search-result-item.selected, .search-suggestion-item.selected');
        
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          if (selected) {
            selected.classList.remove('selected');
            const next = selected.nextElementSibling || items[0];
            next.classList.add('selected');
          } else if (items.length > 0) {
            items[0].classList.add('selected');
          }
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          if (selected) {
            selected.classList.remove('selected');
            const prev = selected.previousElementSibling || items[items.length - 1];
            prev.classList.add('selected');
          } else if (items.length > 0) {
            items[items.length - 1].classList.add('selected');
          }
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (selected) {
            selected.click();
          }
        } else if (e.key === 'Escape') {
          searchResults.style.display = 'none';
          hideLoadingState();
          this.blur();
        } else if (e.key === 'Tab' && selected && selected.classList.contains('search-suggestion-item')) {
          e.preventDefault();
          // Auto-complete with Tab on suggestion
          const suggestionQuery = selected.querySelector('.suggestion-query').textContent;
          this.value = suggestionQuery;
          searchResults.style.display = 'none';
          
          // Track tab completion
          if (window.telemetry) {
            window.telemetry.recordUserAction('search-tab-complete', suggestionQuery);
          }
        }
      });
    });

    // Theme toggle functionality
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      
      html.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);
      
      // Update theme toggle icon
      const themeIcon = document.querySelector('.theme-icon');
      if (themeIcon) {
        themeIcon.textContent = newTheme === 'dark' ? 'â˜€' : 'â˜½';
      }
      
      // Log theme change
      if (window.logger) {
        window.logger.userAction('theme-toggle', { theme: newTheme });
      }
    }

    // Initialize theme on page load
    document.addEventListener('DOMContentLoaded', function() {
      const savedTheme = localStorage.getItem('theme');
      // Default to dark mode (changed from light mode default)
      const initialTheme = savedTheme || 'dark';
      
      document.documentElement.setAttribute('data-theme', initialTheme);
      
      // Update theme toggle icon
      const themeIcon = document.querySelector('.theme-icon');
      if (themeIcon) {
        themeIcon.textContent = initialTheme === 'dark' ? 'â˜€' : 'â˜½';
      }
      
      // Register service worker for offline functionality
      registerServiceWorker();
      
      // Initialize font size settings
      initializeFontSettings();
      
      // Initialize high contrast settings
      initializeHighContrastSettings();
    });

    // Font size management
    function initializeFontSettings() {
      try {
        const savedFontSize = localStorage.getItem('fontSize') || 'medium';
        const savedCustomSize = localStorage.getItem('customFontSize') || '100';
        const savedDyslexiaFont = localStorage.getItem('dyslexiaFont') === 'true';
        const savedLineHeight = localStorage.getItem('increaseLineHeight') === 'true';
        
        // Apply saved settings
        if (savedFontSize === 'custom') {
          setCustomFontSize(savedCustomSize);
          document.getElementById('fontSizeSlider').value = savedCustomSize;
        } else {
          setFontSize(savedFontSize);
        }
        
        if (savedDyslexiaFont) {
          document.getElementById('dyslexiaFont').checked = true;
          toggleDyslexiaFont(true);
        }
        
        if (savedLineHeight) {
          document.getElementById('increaseLineHeight').checked = true;
          toggleLineHeight(true);
        }
        
      } catch (error) {
        console.warn('Failed to load font settings:', error);
      }
    }

    function toggleFontSizeControls() {
      const panel = document.getElementById('fontSizePanel');
      const isVisible = panel.classList.contains('visible');
      
      if (isVisible) {
        panel.classList.remove('visible');
      } else {
        panel.classList.add('visible');
      }
      
      // Track font panel usage
      if (window.telemetry) {
        window.telemetry.recordUserAction('font-controls-toggle', isVisible ? 'close' : 'open');
      }
    }

    // Close font panel with click away
    function closeFontSizePanel() {
      const panel = document.getElementById('fontSizePanel');
      if (panel && panel.classList.contains('visible')) {
        panel.classList.remove('visible');
      }
    }

    function setFontSize(size) {
      const root = document.documentElement;
      
      // Remove custom size class
      root.classList.remove('font-size-custom');
      
      // Remove all font size classes
      root.classList.remove('font-size-small', 'font-size-medium', 'font-size-large', 'font-size-extra-large');
      
      // Add the selected size class
      root.classList.add(`font-size-${size}`);
      
      // Update active button
      document.querySelectorAll('.font-preset-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelector(`[data-size="${size}"]`).classList.add('active');
      
      // Reset slider if not using custom
      if (size !== 'custom') {
        document.getElementById('fontSizeSlider').value = 100;
        document.getElementById('sliderValue').textContent = '100%';
      }
      
      // Save to localStorage
      try {
        localStorage.setItem('fontSize', size);
        if (size !== 'custom') {
          localStorage.removeItem('customFontSize');
        }
      } catch (error) {
        console.warn('Failed to save font size:', error);
      }
      
      // Track font size change
      if (window.telemetry) {
        window.telemetry.recordUserAction('font-size-change', size);
      }
    }

    function setCustomFontSize(value) {
      const root = document.documentElement;
      const percentage = parseInt(value);
      
      // Remove preset classes and add custom
      root.classList.remove('font-size-small', 'font-size-medium', 'font-size-large', 'font-size-extra-large');
      root.classList.add('font-size-custom');
      
      // Set custom font size
      root.style.setProperty('--custom-font-scale', percentage / 100);
      
      // Update slider display
      document.getElementById('sliderValue').textContent = `${percentage}%`;
      
      // Update active button (remove preset selection)
      document.querySelectorAll('.font-preset-btn').forEach(btn => btn.classList.remove('active'));
      
      // Save to localStorage
      try {
        localStorage.setItem('fontSize', 'custom');
        localStorage.setItem('customFontSize', value);
      } catch (error) {
        console.warn('Failed to save custom font size:', error);
      }
      
      // Track custom font size
      if (window.telemetry) {
        window.telemetry.recordUserAction('font-size-custom', percentage);
      }
    }

    function toggleDyslexiaFont(enabled) {
      const root = document.documentElement;
      
      if (enabled) {
        root.classList.add('dyslexia-font');
      } else {
        root.classList.remove('dyslexia-font');
      }
      
      // Save to localStorage
      try {
        localStorage.setItem('dyslexiaFont', enabled.toString());
      } catch (error) {
        console.warn('Failed to save dyslexia font setting:', error);
      }
      
      // Track dyslexia font toggle
      if (window.telemetry) {
        window.telemetry.recordUserAction('dyslexia-font-toggle', enabled);
      }
    }

    function toggleLineHeight(enabled) {
      const root = document.documentElement;
      
      if (enabled) {
        root.classList.add('increased-line-height');
      } else {
        root.classList.remove('increased-line-height');
      }
      
      // Save to localStorage
      try {
        localStorage.setItem('increaseLineHeight', enabled.toString());
      } catch (error) {
        console.warn('Failed to save line height setting:', error);
      }
      
      // Track line height toggle
      if (window.telemetry) {
        window.telemetry.recordUserAction('line-height-toggle', enabled);
      }
    }

    function resetFontSettings() {
      // Reset to defaults
      setFontSize('medium');
      document.getElementById('dyslexiaFont').checked = false;
      document.getElementById('increaseLineHeight').checked = false;
      toggleDyslexiaFont(false);
      toggleLineHeight(false);
      
      // Clear localStorage
      try {
        localStorage.removeItem('fontSize');
        localStorage.removeItem('customFontSize');
        localStorage.removeItem('dyslexiaFont');
        localStorage.removeItem('increaseLineHeight');
      } catch (error) {
        console.warn('Failed to clear font settings:', error);
      }
      
      // Show feedback
      const resetBtn = event.target;
      const originalText = resetBtn.textContent;
      resetBtn.textContent = 'âœ“ Reset';
      resetBtn.style.background = 'var(--success)';
      resetBtn.style.color = 'white';
      
      setTimeout(() => {
        resetBtn.textContent = originalText;
        resetBtn.style.background = '';
        resetBtn.style.color = '';
      }, 1500);
      
      // Track reset
      if (window.telemetry) {
        window.telemetry.recordUserAction('font-settings-reset');
      }
    }

    // High contrast mode management
    function initializeHighContrastSettings() {
      try {
        const savedHighContrast = localStorage.getItem('highContrastMode') === 'true';
        
        if (savedHighContrast) {
          toggleHighContrast(true, false); // true for enabled, false to not save again
        }
        
      } catch (error) {
        console.warn('Failed to load high contrast settings:', error);
      }
    }

    function toggleHighContrast(forceState = null, shouldSave = true) {
      const root = document.documentElement;
      const currentlyEnabled = root.classList.contains('high-contrast');
      const newState = forceState !== null ? forceState : !currentlyEnabled;
      
      if (newState) {
        root.classList.add('high-contrast');
      } else {
        root.classList.remove('high-contrast');
      }
      
      // Update icon
      const contrastIcon = document.querySelector('.high-contrast-icon');
      if (contrastIcon) {
        contrastIcon.textContent = newState ? 'â– ' : 'â—»';
      }
      
      // Save to localStorage
      if (shouldSave) {
        try {
          localStorage.setItem('highContrastMode', newState.toString());
        } catch (error) {
          console.warn('Failed to save high contrast setting:', error);
        }
      }
      
      // Track high contrast toggle
      if (window.telemetry && shouldSave) {
        window.telemetry.recordUserAction('high-contrast-toggle', newState);
      }
      
      // Show brief feedback
      if (shouldSave) {
        showAccessibilityFeedback(newState ? 'High contrast enabled' : 'High contrast disabled');
      }
    }

    function showAccessibilityFeedback(message) {
      // Create and show temporary feedback message
      const feedback = document.createElement('div');
      feedback.className = 'accessibility-feedback';
      feedback.textContent = message;
      feedback.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: var(--accent);
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideInRight 0.3s ease-out;
        box-shadow: 0 4px 12px var(--shadow-lg);
      `;
      
      document.body.appendChild(feedback);
      
      // Auto-remove after 2 seconds
      setTimeout(() => {
        feedback.style.animation = 'slideOutRight 0.3s ease-in forwards';
        setTimeout(() => feedback.remove(), 300);
      }, 2000);
    }

    // Service Worker registration
    async function registerServiceWorker() {
      if ('serviceWorker' in navigator) {
        try {
          const registration = await navigator.serviceWorker.register('/sw.js');
          console.log('SW registered successfully:', registration.scope);
          
          // Handle service worker updates
          registration.addEventListener('updatefound', () => {
            const newWorker = registration.installing;
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                showUpdateAvailable(newWorker);
              }
            });
          });
          
          // Listen for messages from service worker
          navigator.serviceWorker.addEventListener('message', event => {
            handleServiceWorkerMessage(event.data);
          });
          
          // Auto-cache bookmarked pages
          window.addEventListener('bookmark-added', event => {
            if (navigator.serviceWorker.controller) {
              navigator.serviceWorker.controller.postMessage({
                type: 'CACHE_BOOK',
                data: { url: event.detail.url }
              });
            }
          });
          
        } catch (error) {
          console.warn('SW registration failed:', error);
        }
      }
    }

    function handleServiceWorkerMessage(message) {
      const { type, data } = message;
      
      switch (type) {
        case 'BACK_ONLINE':
          showOnlineStatus();
          break;
      }
    }

    function showUpdateAvailable(newWorker) {
      // Show update notification
      const updateNotification = document.createElement('div');
      updateNotification.className = 'update-notification';
      updateNotification.innerHTML = `
        <div class="update-content">
          <div class="update-icon">â†»</div>
          <div class="update-text">
            <strong>Update Available</strong>
            <p>A new version of Bible Explorer is ready!</p>
          </div>
          <div class="update-actions">
            <button onclick="updateServiceWorker()" class="btn-primary">Update</button>
            <button onclick="this.parentElement.parentElement.parentElement.remove()" class="btn-secondary">Later</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(updateNotification);
      
      // Store reference to new worker
      window.newServiceWorker = newWorker;
    }

    function updateServiceWorker() {
      if (window.newServiceWorker) {
        window.newServiceWorker.postMessage({ type: 'SKIP_WAITING' });
        window.location.reload();
      }
    }

    function showOnlineStatus() {
      // Show brief online indicator
      const onlineIndicator = document.createElement('div');
      onlineIndicator.className = 'online-indicator';
      onlineIndicator.innerHTML = `
        <div class="online-content">
          <div class="online-icon">â—</div>
          <span>Back online!</span>
        </div>
      `;
      
      document.body.appendChild(onlineIndicator);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        onlineIndicator.remove();
      }, 3000);
    }
  </script>
</body>
</html>
